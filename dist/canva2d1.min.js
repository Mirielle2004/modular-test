/**
 * Name         : Canva2d.js
 * @author      : Mirielle S. (codeBreaker!)
 * Last Modified: 09.09.2020
 * Revision     : 0.0.2
 * Minified with tersser
 * @url https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3
 * 
 * MIT License
 * 
 * Copyright (c) 2020 CodeBreaker
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */

let CURRENT_CONTEXT;window.requestAnimationFrame=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(t){window.setTimeout(t,1e3/60)};const AbstractBaseMixin={debug:!1,checkDebug(t,i){this.debug&&t(i)}};CanvasRenderingContext2D.prototype.__proto__={clearColor(t,i,e,s,n){this.fillStyle=n,void 0!==n?this.fillRect(t,i,e,s):this.clearRect(t,i,e,s)},line(t,i,e,s,n,h=0){this.strokeStyle=n,ctx.lineWidth=h,this.beginPath(),this.moveTo(t,i),this.lineTo(e,s),this.closePath(),this.stroke()},setShadow(t,i,e,s){this.shadowColor=void 0===t?this.shadowColor:t,this.shadowBlur=void 0===i?this.shadowBlur:i,this.shadowOffsetX=void 0===e?0:e,this.shadowOffsetY=void 0===s?0:s},Joystick2dArc(t,i,e,s,n,h=0){this.save(),this.lineWidth=h,this.strokeStyle=n||s,this.fillStyle=s,this.beginPath(),this.arc(t,i,e,0,2*Math.PI),this.closePath(),"none"!==n&&""!==n&&this.stroke(),void 0!==s&&"none"!==s&&""!==s&&this.fill(),this.restore()}};const Vector=function(t,i){this.x=t,this.y=i,this.magnitude=Math.hypot(this.x,this.y),this.angle=Math.atan2(this.y,this.x)};Vector.prototype={normalise(){this.x/=this.magnitude,this.y/=this.magnitude},add(t){let i=this.x+t.x,e=this.y+t.y;return new Vector(i,e)},subtract(t){let i=this.x-t.x,e=this.y-t.y;return new Vector(i,e)},multiply(t){let i=this.x*t.x,e=this.y*t.y;return new Vector(i,e)},dot(t){return this.x*t.x+this.y*t.y},clone(){return new Vector(this.x,this.y)}},Vector.__proto__={getDist:(t,i)=>new Vector(i.x,i.y).subtract({x:t.x,y:t.y}).magnitude,getPolarCoord(t=0,i=0){let e=Math.cos(t)*i,s=Math.sin(t)*i;return new Vector(e,s)}};class Collision{static circle(t,i){return Vector.getDist(t,i)<t.r+i.r}static rect(t,i){return t.x+t.w>i.x&&i.x+i.w>t.x&&t.y+t.h>i.y&&i.y+i.h>t.y}static rectCircle(t,i){var e=Math.abs(i.x-(t.x+.5*t.w)),s=Math.abs(i.y-(t.y+.5*t.h));return!(e>i.r+.5*t.w)&&(!(s>i.r+.5*t.h)&&(e<=t.w||(s<=t.h||(e=e-t.w)*e+(s=s-t.h)*s<=i.r*i.r)))}static lineIntercept(t,i){let e,s,n,h,a,o;return e=new Vector(t.x1,t.y1).subtract({x:t.x0,y:t.y0}),s=new Vector(i.x1,i.y1).subtract({x:i.x0,y:i.y0}),0!=(h=e.x*s.y-e.y*s.x)&&(n={x:t.x0-i.x0,y:t.y0-i.y0},(o=(e.x*n.y-e.y*n.x)/h)>=0&&o<=1&&((a=(s.x*n.y-s.y*n.x)/h)>=0&&a<=1))}static lineInterceptCircle(t,i){let e=new Vector(i.x,i.y).subtract({x:t.x0,y:t.y0}),s=new Vector(t.x1,t.y1).subtract({x:t.x0,y:t.y0}),n=e.dot(s)/s.dot(s),h=t.x0+s.x*n,a=t.y0+s.y*n;return n<0&&(h=t.x0,a=t.y0),n>1&&(h=t.x1,a=t.y1),new Vector(i.x-h,i.y-a).dot({x:i.x-h,y:i.y-a})<i.r*i.r}static lineInterceptRect(t,i){const e=(t,i)=>{let e=t.x0,s=t.y0,n=t.x1,h=t.y1,a=i.x0,o=i.y0,r=i.x1,c=i.y1,l=(r-a)*(s-o)-(c-o)*(e-a),d=(n-e)*(s-o)-(h-s)*(e-a),y=(c-o)*(n-e)-(r-a)*(h-s);return 0==l&&0==d&&0==y?null:0==y?null:(d/=y,(l/=y)>=0&&l<=1&&d>=0&&d<=1)};return!!e(t,{x0:i.x,y0:i.y,x1:i.x+i.w,y1:i.y+i.h})||(!!e(t,{x0:i.x+i.w,y0:i.y+i.h,x1:i.x+i.w,y1:i.y+i.h})||(!!e(t,{x0:i.x+i.w,y0:i.y+i.h,x1:i.x,y1:i.y+i.h})||!!e(t,{x0:i.x,y0:i.y+i.h,x1:i.x,y1:i.y})))}static pointAtArc(t,i){let e=new Vector(t.x,t.y).subtract({x:i.x,y:i.y}),s=e.dot(e),n=i.r1*i.r1;if(s<i.r0*i.r0||s>n)return!1;let h=(e.angle+2*Math.PI)%(2*Math.PI);return h>=i.angle0&&h<=i.angle1}static pointAtWedge(t,i){let e=new Vector(t.x,t.y).subtract({x:i.x,y:i.y}),s=i.r*i.r;if(e.x*e.x+e.y*e.y>s)return!1;let n=(e.angle+2*Math.PI)%(2*Math.PI);return n>=i.angle0&&n<=i.angle1}static pointAtCircle(t,i){let e=new Vector(i.x,i.y).subtract({x:t.x,y:t.y});return e.x*e.x+e.y*e.y<i.r*i.r}static pointAtSemiCircle(t,i){let e=new Vector(i.x,i.y).subtract({x:t.x,y:t.y});return e.x*e.x+e.y*e.y<i.r}static pointAtRect(t,i){return t.x>i.x&&t.x<i.x+i.w&&t.y>i.y&&t.y<i.y+i.h}static pointAtSemiRect(t,i){return t.x>i.x&&t.x<i.x+.3*i.w&&t.y>i.y&&t.y<i.y+.3*i.h}static elastic(t,i){const e=(t,i)=>({x:t.x*Math.cos(i)-t.y*Math.sin(i),y:t.x*Math.sin(i)+t.y*Math.cos(i)});let s=new Vector(t.vel.x,t.vel.y).subtract({x:i.vel.x,y:i.vel.y}),n=new Vector(i.x,i.y).subtract({x:t.x,y:t.y});if(n.dot(s)>=0){let s=-Math.atan2(n.y,n.x);const h=t.m,a=i.m,o=e(t.vel,s),r=e(i.vel,s),c={x:(h-a)*o.x/(h+a)+2*a*r.x/(h+a),y:o.y},l={x:2*h*o.x/(h+a)+(a-h)*r.x/(h+a),y:r.y},d=e(c,-s),y=e(l,-s);t.vel=new Vector(d.x,d.y),i.vel=new Vector(y.x,y.y)}}static convexPolygon(t,i){}static polygon(t,i){}}const Motion={translateX:0,translateY:0,moveTo(t,i,e){let s=new Vector(i.x,i.y).subtract({x:t.x,y:t.y}),n=Vector.getPolarCoord(s.angle,e);t.x+=n.x,t.y+=n.y},reverseVel(t,i="x"){"x"===i.toLowerCase()?t.vel.x=-t.vel.x:"y"===i.toLowerCase()&&(t.vel.y=-t.vel.y)},addFriction(t,i=.8,e="y"){"x"===e.toLowerCase()?t.vel.x*=i:t.vel.y*=i},addGravity(t,i=0){t.vel.y+=i},moveToBezierCurve(t,i,e){let s=3*(t.x1-t.x0),n=3*(i.x0-t.x1)-s,h=i.x1-t.x0-s-n,a=3*(t.y1-t.y0),o=3*(i.y0-t.y1)-a,r=i.y1-t.y0-a-o;return{x:h*(e*e*e)+n*(e*e)+s*e+t.x0,y:r*(e*e*e)+o*(e*e)+a*e+t.y0}},easeOut(t,i,e){let s=new Vector(i.x,i.y).subtract({x:t.x,y:t.y});t.vel.x=s.magnitude*e,t.vel.y=s.magnitude*e;let n=Vector.getPolarCoord(s.angle,t.vel.x);t.x+=n.x,t.y+=n.y},easeIn(t,i,e){let s=new Vector(i.x,i.y).subtract({x:t.x,y:t.y});t.vel.x+=e;let n=Vector.getPolarCoord(s.angle,t.vel.x);t.x+=n.x,t.y+=n.y},translate(t,i){this.translateX=t,this.translateY=i},rotate(t,i=0,e=0){let s=Vector.getPolarCoord(i,e);t.x=this.translateX+s.x,t.y=this.translateY+s.y}};Math.__proto__={randRange(t=0,i=1){return this.random()*(i-t+1)+t},randFromArray(t){return t[this.random()*t.length|0]},toRadian(t){return t*this.PI/180},toDegree(t){return 180*t/this.PI},getPolarCoord:(t=0,i=0)=>({x:Math.cos(t)*i,y:Math.sin(t)*i}),getDist:(t,i)=>new Vector(i.x,i.y).subtract({x:t.x,y:t.y}).magnitude};class Swipe{constructor(t,i="default"){if(this.element=t,this.direction=null,this.isActive=!1,this.pos=new Vector(0,0),void 0!==i)switch(i.toLowerCase()){case"touch":this.touch();break;case"mouse":this.mouse();break;case"default":"ontouchstart"in window?this.touch():"onmousedown"in window&&this.mouse();break;default:throw new Error(`Swipe of type "${i}" does not exist`)}else"ontouchstart"in window?this.touch():"onmousedown"in window&&this.mouse()}checkSwipe(t,i){let e=i.subtract(t);Math.abs(e.x)>Math.abs(e.y)?e.x<0?this.direction="left":this.direction="right":e.y<0?this.direction="up":this.direction="down"}touch(){this.element.addEventListener("touchstart",t=>{this.isActive=!0,this.pos=new Vector(t.touches[0].pageX,t.touches[0].pageY)}),this.element.addEventListener("touchmove",t=>{this.checkSwipe(this.pos,new Vector(t.touches[0].pageX,t.touches[0].pageY)),this.element.dispatchEvent(new CustomEvent("swipe",{detail:{e:t,isActive:this.isActive,originX:this.pos.x,originY:this.pos.y,clientX:t.touches[0].pageX,clientY:t.touches[0].pageY,direction:this.direction}})),t.preventDefault()}),this.element.addEventListener("touchend",()=>{this.isActive=!1,this.pos=new Vector(0,0)})}mouse(){this.element.addEventListener("mousedown",t=>{this.isActive=!0,this.pos=new Vector(t.clientX,t.clientY)}),this.element.addEventListener("mousemove",t=>{this.isActive&&(this.checkSwipe(this.pos,new Vector(t.clientX,t.clientY)),this.element.dispatchEvent(new CustomEvent("swipe",{detail:{e:t,isActive:this.isActive,originX:this.pos.x,originY:this.pos.y,clientX:t.clientX,clientY:t.clientY,direction:this.direction}})))}),this.element.addEventListener("mouseup",()=>{this.isActive=!1,this.pos=new Vector(0,0)})}}class JoyStick{constructor(t,i){this.canvas=t;try{this.ctx=this.canvas.getContext("2d")}catch(t){throw new Error("Joystick Failed to intialize CANVAS")}if(this.dynamic=!1!==i.dynamic,this.origin=new Vector(i.x||0,i.y||0),this.pos=new Vector(i.x||0,i.y||0),this.direction=null,this.color=i.color||"lightgray",this.lineWidth=i.lineWidth||4,this.outlineColor=i.outlineColor||"#222",this.innerRadius=i.innerRadius||15,this.backgroundColor=i.backgroundColor||"none",this.backgroundOutlineColor=i.backgroundOutlineColor||"#222",this.backgroundLineWidth=i.backgroundLineWidth||4,this.outerRadius=i.outerRadius||50,this.isActive=!1,this.timeSpan=i.fadeIn||100,this.timeSpanCounter=this.timeSpan,this.speedCounter=0,this.isDisplay=!1,this.isFading=!1,this.alpha=1,void 0!==i.type)switch(i.type.toLowerCase()){case"touch":this.touch();break;case"mouse":this.mouse();break;case"default":"ontouchstart"in window?this.touch():"onmousedown"in window&&this.mouse();break;default:console.error(`${i.type} types does not exists`)}else"ontouchstart"in window?this.touch():"onmousedown"in window&&this.mouse()}draw(){this.ctx.save(),this.ctx.globalAlpha=this.alpha,this.ctx.Joystick2dArc(this.origin.x,this.origin.y,this.outerRadius,this.backgroundColor,this.backgroundOutlineColor,this.backgroundLineWidth),this.ctx.Joystick2dArc(this.pos.x,this.pos.y,this.innerRadius,this.color,this.outlineColor,this.lineWidth),this.ctx.restore()}fadeIn(){this.isFading&&(this.timeSpanCounter-=1,this.alpha=Math.abs(this.timeSpanCounter/this.timeSpan),this.alpha<=0&&(this.isDisplay=!1,this.timeSpanCounter=this.timeSpan))}checkSwipe(t,i){let e=i.subtract(t);Math.abs(e.x)>Math.abs(e.y)?e.x<0?this.direction="left":this.direction="right":e.y<0?this.direction="up":this.direction="down"}mouse(){this.canvas.addEventListener("mousedown",t=>{if(this.dynamic){let i=this.canvas.getBoundingClientRect();this.origin=new Vector(t.clientX,t.clientY).subtract({x:i.x,y:i.y}),this.pos=new Vector(t.clientX,t.clientY).subtract({x:i.x,y:i.y}),this.isDisplay=!0,this.isFading=!1,this.alpha=1}this.isActive=!0}),this.canvas.addEventListener("mousemove",t=>{if(this.isActive){let i=this.canvas.getBoundingClientRect(),e=new Vector(t.clientX,t.clientY).subtract({x:i.x,y:i.y}).subtract(this.origin);this.checkSwipe(this.origin,new Vector(t.clientX,t.clientY));let s=Math.min(e.magnitude,this.outerRadius);this.pos.x=this.origin.x+Math.cos(e.angle)*s,this.pos.y=this.origin.y+Math.sin(e.angle)*s,this.canvas.dispatchEvent(new CustomEvent("joystick",{detail:{e:t,angle:e.angle,magnitude:e.magnitude,direction:this.direction,originX:this.origin.x,originY:this.origin.y,clientX:t.clientX,clientY:t.clientY,isActive:this.isActive}}))}}),this.canvas.addEventListener("mouseup",()=>{this.dynamic?(this.isActive=!1,this.isFading=!0):this.pos=new Vector(this.origin.x,this.origin.y),this.direction=null})}touch(){this.canvas.addEventListener("touchstart",t=>{if(this.dynamic){let i=this.canvas.getBoundingClientRect();this.origin=new Vector(t.touches[0].pageX,t.touches[0].pageY).subtract({x:i.x,y:i.y}),this.pos=new Vector(t.touches[0].pageX,t.touches[0].pageY).subtract({x:i.x,y:i.y}),this.isDisplay=!0,this.isFading=!1,this.alpha=1}this.isActive=!0}),this.canvas.addEventListener("touchmove",t=>{let i=this.canvas.getBoundingClientRect(),e=new Vector(t.touches[0].pageX,t.touches[0].pageY).subtract({x:i.x,y:i.y}).subtract(this.origin),s=Math.min(e.magnitude,this.outerRadius);this.pos.x=this.origin.x+Math.cos(e.angle)*s,this.pos.y=this.origin.y+Math.sin(e.angle)*s,this.checkSwipe(this.origin,new Vector(t.clientX,t.clientY)),this.canvas.dispatchEvent(new CustomEvent("joystick",{detail:{e:t,angle:e.angle,magnitude:e.magnitude,direction:this.direction,originX:this.origin.x,originY:this.origin.y,clientX:t.clientX,clientY:t.clientY,isActive:this.isActive}})),t.preventDefault()}),this.canvas.addEventListener("touchend",()=>{this.dynamic?this.isFading=!0:this.pos=new Vector(this.origin.x,this.origin.y),this.isActive=!1})}show(){this.dynamic?(this.isDisplay&&this.draw(),this.fadeIn()):(this.isFading=!1,this.isDisplay=!0,this.alpha=1,this.draw())}hide(){this.isDisplay=!1,this.isActive=!1}}class Component extends Vector{constructor({x:t=0,y:i=0,w:e=0,h:s=0,r:n=null,x0:h=null,y0:a=null,x1:o=null,y1:r=null}){super(t,i),this.w=e,this.h=s,this.r=n,this.x0=h,this.x1=o,this.y0=a,this.y1=r,this.vel=new Vector(0,0),this.s=0,this.m=5,this.type=null!==this.x0?"line":null!==this.r?"circle":"polygon"}getCenterX(){return"circle"===this.type?this.x:"line"!==this.type?this.x+.5*this.w:void 0}getCenterY(){return"circle"===this.type?this.y:"line"!==this.type?this.y+.5*this.h:void 0}}class Camera extends Vector{constructor(t=0,i=0,e=0,s=0){super(t,i),this.w=e,this.h=s,this.maxDimension=new Vector(0,0)}follow(t){if(0===this.maxDimension.y&&0===this.maxDimension.x)throw new Error("Please provide the maximum dimension for the camera");let i=new Vector(t.getCenterX(),t.getCenterY()).subtract({x:.5*this.w,y:.5*this.h});this.x=i.x,this.y=i.y,this.x=Math.min(Math.max(0,this.x),Math.min(this.maxDimension.x-this.w,Math.max(0,i.x))),this.y=Math.min(Math.max(0,this.y),Math.min(this.maxDimension.y-this.h,Math.max(0,i.y)))}}class Sprite extends Component{constructor(t,i,e,s,n,h,a=0){super({x:t,y:i,w:e,h:s}),this.data=n,this.img=this.data.img,this.tileW=this.data.w,this.tileH=this.data.h,this.spacing=this.data.spacing,this.frame=this.data.frame.filter(t=>t.name===h)[0],this.frameName="",this.currentFrame=[],this.frameIndex=0;for(const t in this.frame)this.setFrame(t);this.src=new Vector(void 0,void 0),this.delay=a,this.maximumDelay=a}setFrame(t){if(this.frameName=t,void 0===this.frame[t])throw new Error(`"${t}" is not a valid frame's name`);this.currentFrame=this.frame[t]}getFrame(){return this.frameName}animate(){if(this.currentFrame.length<1||!(this.currentFrame instanceof Array))throw new Error("Current Animation's Frame does not exist");if(this.delay--,this.delay<0){this.delay=this.maximumDelay,this.frameIndex++,this.frameIndex>=this.currentFrame.length&&(this.frameIndex=0);let t=this.currentFrame[this.frameIndex]-1;this.src=this.data.indexAt(t)}}}class TileMap{constructor({map:t=[0],w:i,h:e,camera:s,path:n=[]}){if(this.map=t,!(this.map instanceof Array)||this.map.length<=0)throw new Error("world map can only be respresented as a 2D Array");if(this.w=i,this.h=e,this.mapSize=new Vector(this.map[0].length,this.map.length),this.mapDimension=new Vector(this.w,this.h).multiply(this.mapSize),this.camera=s||new Camera(0,0,this.mapDimension.x,this.mapDimension.y),!(this.camera instanceof Camera))throw new Error("Failed to initialize camera: camera must be an instance of `Camera`");this.camera.maxDimension=this.mapDimension,this.path=n,this.id=null,this.row=null,this.col=null}setMap(t){this.map=t}getMap(){return this.map}renderMap(t){let i=~~(this.camera.x/this.w),e=~~(this.camera.y/this.h),s=Math.ceil((this.camera.x+this.camera.w)/this.w),n=Math.ceil((this.camera.y+this.camera.h)/this.h);for(let h=e;h<n;h++)for(let e=i;e<s;e++)this.id=this.map[h][e],this.row=h,this.col=e,t()}tileAt(t,i){let e=new Vector(~~(t/this.w),~~(i/this.h));return this.map[e.y][e.x]}}Object.assign(TileMap.prototype,AbstractBaseMixin);class TileSet{constructor(t){this.img=new Image,this.img.src=t.img,this.w=t.w,this.h=t.h,this.col=t.col,this.row=t.row,this.spacing=t.spacing||0,this.frame=t.frame}tileAt(t){return new Vector(t.x/this.w,t.y/this.h)}indexAt(t){let i=~~(t%this.col),e=~~(t/this.col);return new Vector(i,e)}valueAt(t,i){return t*this.col+i}}class Scene{constructor({canvas:t,width:i,height:e,backgroundColor:s,controls:n}){this.canvas=t;try{this.ctx=this.canvas.getContext("2d")}catch(t){throw new Error("Failed to initialize canvas: "+t.message)}this.width=i||300,this.height=e||300,this.canvas.width=this.width,this.canvas.height=this.height,this.controls=n||[],this.joystick=null,this.swipe=null,this.controls.forEach((t,i)=>{"swipe"===t.event?this.swipe=new Swipe(this.canvas,t.type):"joystick"===t.event&&(this.joystick=new JoyStick(this.canvas,t.style))}),void 0!==s&&(this.canvas.style.backgroundColor=s),this.startLoop=(t=>requestAnimationFrame(t)),this.elapsedTime=0,this.animationFrame=null,this.timeEnded=null,this.timeStarted=null,this.fps=null,this.cursorType="ontouchstart"in window?"touch":"onmousedown"in window?"mouse":null,this.cursor=new Vector(null,null);const h=t=>{let i=this.canvas.getBoundingClientRect();"mouse"===this.cursorType?this.cursor=new Vector(t.clientX,t.clientY).subtract({x:i.left,y:i.top}):"touch"===this.cursorType&&(this.cursor=new Vector(t.touches[0].pageX,t.touches[0].pageY).subtract({x:i.left,y:i.top}))};"mouse"===this.cursorType?(this.canvas.addEventListener("click",h),this.canvas.addEventListener("mousedown",h),this.canvas.addEventListener("mousemove",h),this.canvas.addEventListener("mouseup",h)):"touch"===this.cursorType&&(this.canvas.addEventListener("click",h),this.canvas.addEventListener("touchstart",h),this.canvas.addEventListener("touchmove",h),this.canvas.addEventListener("touchend",h)),Scene.setContext(this.canvas)}calcFps(){this.timeEnded=performance.now(),this.fps=1e3/(this.timeEnded-this.timeStarted),this.timeStarted=this.timeEnded}mainLoop(t){const i=e=>{this.elapsedTime=e,this.animationFrame=i,t()};this.startLoop(i)}static setContext(t){try{CURRENT_CONTEXT=t.getContext("2d")}catch(t){throw new Error(`Failed to set the global variable "CURRENT_CONTEXT": ${t.message}`)}}}
